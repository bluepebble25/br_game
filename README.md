### [TCP/IP 기말과제] 201944045 B 이현지
## br_game (2인용 베스킨라빈스 31게임)

## 개요
- Python으로 구현
- 서버에 두 명의 클라이언트가 접속해 소켓 통신을 통해 플레이할 수 있는 베스킨라빈스 31 게임
- 게임 설명: 1개에서 최대 3개의 숫자를 부를 수 있고, 1부터 시작해서 마지막에 31을 부른 사람이 지는 게임이다.

## 목적
서버에 클라이언트 두 대가 접속해 즐길 수 있는 2인용 통신 게임 제작

## 설계 및 기능
### 서버)
1. 유저가 접속할 때마다 누가 접속했는지, 현재 인원수는 몇 명인지 모두에게 알려줌.
2. 서버에 접속한 인원이 2명이면 게임 시작
3. 난수 생성해 처음으로 시작할 사람 선택
4. 해당하는 플레이어에게 "input"을 보내 입력할 차례라는 것 알려줌
5. 숫자 입력받으면 클라이언트가 전송한 숫자(부를 숫자의 개수)만큼의 다음 숫자를 전송<br> ex) ㅇㅇ님: 5 6 7
7. 0이나 "/quit" 받으면 게임 종료 및 누가 나갔는지 접속자에게 알려줌 [(구현 실패)](#구현실패한-기능-회고)
8. 숫자가 31이 되면 이긴 사람이 누구인지 모두에게 알려주고 게임 종료. 다시 2번으로 돌아감

### 클라이언트)
1. 서버에 연결 및 입력한 닉네임 전송
2. 서버에 접속 인원이 2명이 될 때까지 대기
3. 게임하는 동안 "input"을 서버로부터 전송 받으면 1~3 숫자 입력
4. 진행상황 전송받기 ex) ㅇㅇ님: 5 6 7
5. 숫자가 31이 되기 전까지 반복
6. 이번 판에서 이긴 사람의 이름 전송받기
7. 게임 도중 "/quit" 전송하면 프로그램 종료

## 차이점
수업시간에 배운 채팅 프로그램에서 있었으면 하는 기능을 추가하였음.
1.  클라이언트가 입장할 때마다 닉네임과 접속했다는 문구, 현재 몇 명이 접속해 있는지 알려주는 기능
2.  말하고 있는 상대방이 누구인지 앞에 닉네임을 붙여 구별해주는 기능
3. 클라이언트가 나가면 모두에게 누가 나갔다고 알려주고 게임을 정지하는 기능 [(구현 실패)](#구현실패한-기능-회고)

- 클라이언트가 나가는 것을 감지하는 isQuit 스레드와 정보를 수신하는 스레드를 멀티스레드로 구현하려 하였다.
- isQuit 함수를 스레드로 실행하는 이유:
<br>자신의 입력 차례가 아니거나 게임 로직 도중에는 종료한다는 명령어를 서버에 전송하지 못하기 때문에,<br>
종료를 감지하고 적절한 행동(ㅇㅇ님이 나갔다는 문구 전송, 게임 중단하는 일)을 하기 위함이다.
4. 게임이다보니 정보를 입력할 수 있는 차례가 정해져 있어, 클라이언트가 "input"을 받았을 때만 송신할 수 있는 프로토콜을 만들어 순서 제어함.

## 구현실패한 기능 회고
0이나 "/quit" 받으면 게임 종료 및 누가 나갔는지 접속자에게 알려주는 기능
- 설계<br>
accpet_client 스레드에서 클라이언트의 접속을 받고, 그 안에서 각 클라이언트가 나갔는지 검사하고 나갔다는 메세지를 모두에게 알리는 *isQuit 스레드*를 클라이언트마다 실행해 멀티스레드로 구현하려고 했음.
- 실제<br>
1) 실행화면의 etc_1), etc_2)처럼, "/quit"을 전송해 나간다는 의사를 표명한 클라이언트의 종료는 잘 된다. 하지만 서버가 해당 클라이언트가 나갔다는 메시지를 전송하려고 하는 과정에서 서버에 오류가 발생한다. 그래서 게임 진행이 계속 안 되고 상대방 클라이언트는 게임 진행에는 문제가 없으나 상대방 클라이언트가 종료했다는 메세지를 받지 못하고, 서버가 게임 진행을 하지 않기 때문에 아무것도 하지 못하는 상태가 된다.<br>
2) 그래서 *isQuit 함수*를 실행하지 않고, 게임 로직에서 유저로부터 입력받는 차례에 /quit을 받아 해당 클라이언트 종료 처리를 할 수 있도록 구현하려 했으나 이 때에도 오류가 발생했다.
- 원인분석<br>
▶설계 계획상에서는 *isQuit함수*를 멀티스레드로 실행해 각 client_sock의 입력(0 값이나 /quit)을 recv로 계속 감지하여,<br>
자신의 입력차례가 아니어도 상대방이 나가는 것을 감지할 수 있도록 하려 했다.<br>
하지만 recv가 두 개이고 멀티스레드로 실행되다보니, game 로직 내에서 받아야 할 값을 예상치 못하게 isQuit함수가 받아 게임이 진행되지 않는 상황이 발생하였다.<br>
그래서 전역변수로 game 로직이 recv로 받은 값을 공유하려 했지만, 한 변수를 여러 클라이언트의 isQuit 멀티스레드가 공유해야 했기에 어느 클라이언트가 종료했는지 모르는 상황이 발생함.<br>
▶또한 "/quit"을 보내지 않고 그냥 종료한 경우를 대비해 recv값이 0이면 종료하도록 했는데, 우아한 종료(graceful close)가 아닌 경우에는(예-ctrl+c로 인터럽트 발생) 0이 전송되지 않는 상황이 발생. 사실 이를 해결하려면 try~exception으로 인터럽트를 감지해 signal 함수를 등록하면 되었지만, 게임 로직 도중에 유저를 제거하면 인덱스 범위 오류가 생기는 것이 문제였음.
- 생각하는 해결책
###### 유저가 나가는 것을 감지하고 적절한 행동을 취하도록 하는 isQuit 기능을 위해서는...<br>
game 로직에서 클라이언트가 숫자를 입력한 다음 아주 잠깐 sleep이나 lock으로 isQuit 함수를 잠그거나, 공유변수를 이용하면서도 각 클라이언트를 구별할 수 있는 프로토콜을 정하면 될 것 같다.<br>
그리고 인터럽트(ctrl+c)로 종료된 경우에는, 유저 제거가 게임로직에 오류를 발생시키지 않도록 게임로직을 중지시키는 방법을 강구해야 할 것이다.

## 실행화면
- 서버시작<br>
![1_서버시작](https://user-images.githubusercontent.com/71175587/122372153-68cbcf80-cf9b-11eb-962b-07e88dc5d34d.png)
<br><br>
- 클라이언트 1명 입장<br>
![2-1_클라이언트 1명 입장](https://user-images.githubusercontent.com/71175587/122372373-94e75080-cf9b-11eb-9aca-d587ee121e5c.png)
<br><br>
- 클라이언트 2명 입장, 게임 시작<br>
![2-2_클라이언트 2명 입장 및 게임시작](https://user-images.githubusercontent.com/71175587/122372539-b6483c80-cf9b-11eb-9af1-21569b1fa6ac.png)
<br><br>
- 게임시작<br>
![3-1_게임시작](https://user-images.githubusercontent.com/71175587/122372569-be07e100-cf9b-11eb-98ca-0062dd82f81b.png)
<br><br>
- 31 도달<br>
![3-2_31도달](https://user-images.githubusercontent.com/71175587/122372728-e1329080-cf9b-11eb-8ef9-9e20cad2c51b.png)
<br><br>
- etc_1) 입력값 검증 및 클라이언트 종료<br>
![etc-1_입력값 검증 및 클라이언트 종료](https://user-images.githubusercontent.com/71175587/122372857-fb6c6e80-cf9b-11eb-8fd4-81c71815f600.png)
<br><br>
- etc_2) 예외상황 (클라이언트 종료 시 상대방과 서버의 게임이 제대로 종료 안되는 문제)
![etc-2_예외상황](https://user-images.githubusercontent.com/71175587/122372930-0921f400-cf9c-11eb-8c0d-6ff4f9b3b788.png)





